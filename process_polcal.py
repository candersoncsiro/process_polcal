#!/usr/bin/env python

genInfo = """process_polcal.py, written by Craig Anderson 17/11/17.

process_polcal.py is a pipeline for on-axis polarisation calibration of ASKAP. It requires that 
the science data and 1934 data have been split out into a folder structure identical to 
that generated by the processASKAP pipeline (ver 0.19.5). In addition, a bandpass calibration must have 
been performed, and a PAF on one array antenna must have been rotated to provide 
the leakage signal required for the cal.
"""

# Import packages
import re
import numpy as np
from subprocess import call
import argparse
import commands
import os
import shutil
import glob

def main(args):

	#Settings
	on = 1
	off = 0

	##Parse args
	baseDir = args.baseDir
	sb1934 = args.sb1934
	sbScience = args.sbScience
	ridiculousStr = args.ridiculousStr
	fieldName = args.fieldName
	interleavesList = args.interleavesList.split(',')
	rotAnt = args.rotAnt
	rotSens = args.rotSens
	nAnt = args.nAnt
	nChan = args.nChan
	mailTo = args.mailTo
	nBeam = args.nBeams-1
	submit_jobs = args.submit_jobs
	cleanUp = args.clean_up
	doLeakPlots = args.doLeakPlots
	makeCopies = args.makeCopies

	if baseDir[-1]!='/':
		baseDir = baseDir+'/'

	##Check for/create necessary dirs
	if not os.path.isdir(baseDir+'slurmFiles'):
		raise OSError('The slurmFiles subdir does not exist! Have you run processASKAP yet? Note that the polcal pipeline requires that the 1934 and science data have been split out, and that an initial bandpass calibration has been performed!')	

	if not os.path.isdir(baseDir+'script_io'):
		os.mkdir(baseDir+'script_io')

	if not os.path.isdir(baseDir+'script_io/POLCAL/'):
		os.mkdir(baseDir+'script_io/POLCAL/')

	if not os.path.isdir(baseDir+'script_io/POLCAL/logFiles'):
		os.mkdir(baseDir+'script_io/POLCAL/logFiles')

	if not os.path.isdir(baseDir+'slurmFiles/POLCAL'):
		os.mkdir(baseDir+'slurmFiles/POLCAL/')

	if not os.path.isdir(baseDir+'slurmFiles/POLCAL/slurmOutput'):
		os.mkdir(baseDir+'slurmFiles/POLCAL/slurmOutput')

	if not os.path.isdir(baseDir+'slurmFiles/POLCAL/slurmInput'):
		os.mkdir(baseDir+'slurmFiles/POLCAL/slurmInput')

	if not os.path.isdir(baseDir+'slurmFiles/POLCAL/slurmError'):
		os.mkdir(baseDir+'slurmFiles/POLCAL/slurmError')

	if cleanUp == 1:

		print ''
		print 'Clean-up flag has been set to ON. Clobbering/restoring old data!'
		print ''

		#Clean up from previous runs that failed
		itemsToClean = glob.glob(baseDir+'BPCAL/'+'*apply*')+glob.glob(baseDir+'script_io/'+'*')+glob.glob(baseDir+'slurmFiles/POLCAL/'+'*.*')
		for item in itemsToClean:
			print 'Clobbering '+item
			if os.path.isfile(item):
				os.remove(item)
			elif os.path.isdir(item):
				shutil.rmtree(item)
			else:
				print 'Weird --- glob found something that is not a file or a folder!'
				pass 

		#Now clean out the interleave folders, and restore the split out science data
		for interleave in interleavesList:
			if 'N' not in interleavesList:
				os.chdir(baseDir+fieldName+'_T<RIDICULOUSSTR>'+interleave)
			else:
				os.chdir(baseDir+fieldName)
			if not glob.glob('./*_preBPapply*'):
				continue
			else:
				itemsToClean = [item for item in glob.glob('./scienceData*.ms') if '_preBPapply' not in item]
				for item in itemsToClean:
					print 'Clobbering '+item
					if os.path.isfile(item):
						os.remove(item)
					elif os.path.isdir(item):
						shutil.rmtree(item)
					else:
						print 'Weird --- glob found something that is not a file or a folder!'
						pass 

			#Restore the unsullied science data files to their original glory
			restorList = glob.glob('./*_preBPapply*')
			for ms in restorList:
				print 'Restoring '+ms.replace('_preBPapply','')
				shutil.move(ms,ms.replace('_preBPapply',''))  
						  ##Check for/create necessary dirs

				#Re-create directories if need be
				if not os.path.isdir(baseDir+'slurmFiles'):
						raise OSError('The slurmFiles subdir does not exist! Have you run processASKAP yet? Note that the polcal pipeline requires that the 1934 and science data have been split out, and that an initial bandpass calibration has been performed!')

				if not os.path.isdir(baseDir+'script_io'):
						os.mkdir(baseDir+'script_io')

				if not os.path.isdir(baseDir+'script_io/POLCAL/'):
						os.mkdir(baseDir+'script_io/POLCAL/')

				if not os.path.isdir(baseDir+'script_io/POLCAL/logFiles'):
						os.mkdir(baseDir+'script_io/POLCAL/logFiles')

				if not os.path.isdir(baseDir+'slurmFiles/POLCAL'):
						os.mkdir(baseDir+'slurmFiles/POLCAL/')

				if not os.path.isdir(baseDir+'slurmFiles/POLCAL/slurmOutput'):
						os.mkdir(baseDir+'slurmFiles/POLCAL/slurmOutput')

				if not os.path.isdir(baseDir+'slurmFiles/POLCAL/slurmInput'):
						os.mkdir(baseDir+'slurmFiles/POLCAL/slurmInput')

				if not os.path.isdir(baseDir+'slurmFiles/POLCAL/slurmError'):
						os.mkdir(baseDir+'slurmFiles/POLCAL/slurmError')

	else:
		print ''
		print 'WARNING: Not clobbering any data from previous runs. If things fall over, this may be why. Perhaps try the -k 1 flag next time to run a clean up?'
		print ''

	#Tell the user what we're doing
	print ''
	print '*******************************************************************************'
	print '*                                                                             *'
	print '*                              PROCESS_POLCAL                                 *'
	print '*                                                                             *'
	print '*                 Written by Craig Anderson, 18 Nov 2017                      *'
	print '*                                                                             *'
	print '* 				   ,--.!,                                     *'
	print '* 				__/   -*-                                     *'
	print '* 			  ,d08b.      \'|`                                     *'
	print '* 			  0088MM                                              *'
	print '* 			  `9MMP\'                                              *'
	print '*                                                                             *'
	print '*******************************************************************************'
	print ''
	print ''
	print 'Check yourself don\'t wreck yourself:'
	print ''
	if 'N' not in interleavesList:
		print '> Doing pol cal for interleave(s) '+ ','.join(interleavesList) +' of field '+fieldName
	else:
		print '> Doing pol cal for field '+fieldName
		print 'You\'ve specified that interleaving was not used for these observations.'  
	print '> Using SB'+ sb1934 +' for the 1934 cal data and SB'+sbScience+' for the target field.'
	print '> You\'ve specified that there are %s antennas in the array, %s formed beams, and %s one-MHz channels across the band.'%(nAnt,nBeam+1,nChan)
	print '> You\'ve specified that antenna #'+ str(rotAnt) +' has a '+str(rotSens).replace('-1','counterclockwise').replace('1','clockwise')+' PAF rotation.'
	print ''
	if submit_jobs==1:
		print 'Hot damn --- you\'re submitting the compute jobs! I like the cut of your jib!'
	else:
		print 'You\'ve opted to check the batch files before job submission:'
	print ''

	##Generate slurm files necessary for the pol cal
	a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=00:10:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_applyBP1934
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/bpapply_1934_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/bpapply_1934_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

#Copy the 1934 tasks 
cp -Trv ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}.ms ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}_apply.ms

parset=./slurmFiles/POLCAL/slurmInput/bpapply_1934_${BEAM_ID}.in

cat > $parset << EOFINNER
Ccalapply.dataset                         = ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}_apply.ms
#
# Allow flagging of vis if inversion of Mueller matrix fails
Ccalapply.calibrate.allowflag             = true
Ccalapply.calibrate.scalenoise            = false
#
Ccalapply.calibaccess                     = table
Ccalapply.calibaccess.table.maxant        = <NANTSTR>
Ccalapply.calibaccess.table.maxbeam       = 1
Ccalapply.calibaccess.table.maxchan       = """+str(int(54*nChan))+"""
Ccalapply.calibaccess.table               = ./BPCAL/calparameters_1934_bp_SB<SB1934STR>.tab

EOFINNER

log=./script_io/POLCAL/logFiles/bpapply_1934_${BEAM_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalapply -c $parset > $log
err=$?

"""

	with open(baseDir+'slurmFiles/POLCAL/apply_bandpass_1934.sbatch','wb') as f:
		print '> Writing apply_bandpass_1934.sbatch...'
		f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))

	a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=01:30:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_onAxFdepLeakCal
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/calibonaxis_leakages_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/calibonaxis_leakages_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

#^^The array should refer to the beam indexes

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

NCHAN=54

#For each channel
for CHANNEL_ID in {0..<NCHANSTR2>}
do

parset=./slurmFiles/POLCAL/slurmInput/calibonaxis_leakages.b${BEAM_ID}_c${CHANNEL_ID}.in

CHAN=`expr ${CHANNEL_ID} \* ${NCHAN}`

cat > $parset << EOFINNER

Ccalibrator.dataset                               = ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}_apply.ms
Ccalibrator.nAnt                                  = <NANTSTR>
Ccalibrator.nBeam                                 = 1
Ccalibrator.refantenna                            = <ROTANTSTR>
Ccalibrator.Channels                              = [$NCHAN,$CHAN]
Ccalibrator.solve                                 = antennagains,leakages
Ccalibrator.MinUV                                 = 100
Ccalibrator.calibaccess                           = parset
Ccalibrator.calibaccess.parset                    = ./script_io/parset_leakages.b${BEAM_ID}_c${CHANNEL_ID}
Ccalibrator.sources.names                         = [field1]
Ccalibrator.sources.field1.direction              = [19h39m25.036, -63.42.45.63, J2000]
Ccalibrator.sources.field1.components             = src
Ccalibrator.sources.src.calibrator                = 1934-638
Ccalibrator.gridder                               = SphFunc
Ccalibrator.ncycles                               = 25


EOFINNER

log=./script_io/POLCAL/logFiles/calibonaxis_leakages.b${BEAM_ID}_c${CHANNEL_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalibrator -c $parset > $log

done
"""

	with open(baseDir+'slurmFiles/POLCAL/calibonaxis_freqdep_leakages_allbeamschans.sbatch','wb') as f:
		print '> Writing calibonaxis_freqdep_leakages_allbeamschans.sbatch...'
		f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<NCHANSTR2>',str(nChan-1)).replace('<MAILSTR>',str(mailTo)))



	a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=00:30:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_flagBadPolcal
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/flag_bad_polcal_channels_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/flag_bad_polcal_channels_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR

#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers


log=./script_io/POLCAL/logFiles/flag_bad_polcal_channels_${BEAM_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} flag_bad_polcal_channels.py <BASESTR> <SB1934STR> ${BEAM_ID} -tu 0.13 -tl 0.03 > $log
err=$?

"""

	with open(baseDir+'slurmFiles/POLCAL/flag_bad_polcal_channels.sbatch','wb') as f:
		print '> Writing flag_bad_polcal_channels.sbatch...'
		f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<NCHANSTR2>',str(nChan-1)).replace('<MAILSTR>',str(mailTo)))



	a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=01:30:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_onAxFdepLeakCal_postXY
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/calibonaxis_leakages_postXY_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/calibonaxis_leakages_postXY_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

#^^The array should refer to the beam indexes

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

NCHAN=54

#For each channel
for CHANNEL_ID in {0..<NCHANSTR2>}
do

parset=./slurmFiles/POLCAL/slurmInput/calibonaxis_leakages_postXY.b${BEAM_ID}_c${CHANNEL_ID}.in

CHAN=`expr ${CHANNEL_ID} \* ${NCHAN}`

cat > $parset << EOFINNER

Ccalibrator.dataset                               = ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}_postXYapply.ms
Ccalibrator.nAnt                                  = <NANTSTR>
Ccalibrator.nBeam                                 = 1
Ccalibrator.refantenna                            = <ROTANTSTR>
Ccalibrator.Channels                              = [$NCHAN,$CHAN]
Ccalibrator.solve                                 = antennagains,leakages
Ccalibrator.MinUV                                 = 100
Ccalibrator.calibaccess                           = parset
Ccalibrator.calibaccess.parset                    = ./script_io/parset_leakages_postXY.b${BEAM_ID}_c${CHANNEL_ID}
Ccalibrator.sources.names                         = [field1]
Ccalibrator.sources.field1.direction              = [19h39m25.036, -63.42.45.63, J2000]
Ccalibrator.sources.field1.components             = src
Ccalibrator.sources.src.calibrator                = 1934-638
Ccalibrator.gridder                               = SphFunc
Ccalibrator.ncycles                               = 25


EOFINNER

log=./script_io/POLCAL/logFiles/calibonaxis_leakages_postXY.b${BEAM_ID}_c${CHANNEL_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalibrator -c $parset > $log

done
"""

	with open(baseDir+'slurmFiles/POLCAL/calibonaxis_freqdep_leakages_allbeamschans_doover.sbatch','wb') as f:
		print '> Writing calibonaxis_freqdep_leakages_allbeamschans_doover.sbatch...'
		f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<NCHANSTR2>',str(nChan-1)).replace('<MAILSTR>',str(mailTo)))


	a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=00:10:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_applyBP1934postXY
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/bpapply_1934_postXY_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/bpapply_1934_postXY_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

#Copy the 1934 tasks 
cp -Trv ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}.ms ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}_postXYapply.ms

parset=./slurmFiles/POLCAL/slurmInput/bpapply_1934_postXY_${BEAM_ID}.in

cat > $parset << EOFINNER
Ccalapply.dataset                         = ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}_postXYapply.ms
#
# Allow flagging of vis if inversion of Mueller matrix fails
Ccalapply.calibrate.allowflag             = true
Ccalapply.calibrate.scalenoise            = false
#
Ccalapply.calibaccess                     = table
Ccalapply.calibaccess.table.maxant        = <NANTSTR>
Ccalapply.calibaccess.table.maxbeam       = 1
Ccalapply.calibaccess.table.maxchan       = """+str(int(54*nChan))+"""
Ccalapply.calibaccess.table               = ./BPCAL/calparameters_1934_bp_SB<SB1934STR>.tab.xy

EOFINNER

log=./script_io/POLCAL/logFiles/bpapply_1934_postXY_${BEAM_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalapply -c $parset > $log
err=$?

"""

	with open(baseDir+'slurmFiles/POLCAL/apply_bandpass_1934_postxy.sbatch','wb') as f:
		print '> Writing apply_bandpass_1934_postxy.sbatch...'
		f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))


	#Generate the sbatch files for all interleaves
	for interleave in interleavesList:
		if interleave!='N': 
			a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=12:00:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_<INTERSTR>_applyBPsci
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/bpapply_sci_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/bpapply_sci_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

#Copy the 1934 tasks 
cp -Trv ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}.ms ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}_preBPapply.ms

parset=./slurmFiles/POLCAL/slurmInput/bpapply_sci_interA_${BEAM_ID}.in

cat > $parset << EOFINNER
Ccalapply.dataset                         = ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}.ms
#
# Allow flagging of vis if inversion of Mueller matrix fails
Ccalapply.calibrate.allowflag             = true
Ccalapply.calibrate.scalenoise            = false
#
Ccalapply.calibaccess                     = table
Ccalapply.calibaccess.table.maxant        = <NANTSTR>
Ccalapply.calibaccess.table.maxbeam       = 1
Ccalapply.calibaccess.table.maxchan       = """+str(int(54*nChan))+"""
Ccalapply.calibaccess.table               = ./BPCAL/calparameters_1934_bp_SB<SB1934STR>.tab.xy

EOFINNER

log=./script_io/POLCAL/logFiles/bpapply_sci_interA_${BEAM_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalapply -c $parset > $log
err=$?

"""
			if makeCopies==off:
				copyString = 'cp -Trv ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}.ms ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}_preBPapply.ms'
				a.replace(copyString,'')
			
			with open(baseDir+'slurmFiles/POLCAL/apply_bandpass_science_'+str(interleave)+'.sbatch','wb') as f:
				print '> Writing apply_bandpass_science_'+str(interleave)+'.sbatch...'
				f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<INTERSTR>',str(interleave)).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))

		elif interleave=='N':

			a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=12:00:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_applyBPsci
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/bpapply_sci_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/bpapply_sci_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

#Copy the 1934 tasks 
cp -Trv ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}.ms ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}_preBPapply.ms

parset=./slurmFiles/POLCAL/slurmInput/bpapply_sci_interA_${BEAM_ID}.in

cat > $parset << EOFINNER
Ccalapply.dataset                         = ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}.ms
#
# Allow flagging of vis if inversion of Mueller matrix fails
Ccalapply.calibrate.allowflag             = true
Ccalapply.calibrate.scalenoise            = false
#
Ccalapply.calibaccess                     = table
Ccalapply.calibaccess.table.maxant        = <NANTSTR>
Ccalapply.calibaccess.table.maxbeam       = 1
Ccalapply.calibaccess.table.maxchan       = """+str(int(54*nChan))+"""
Ccalapply.calibaccess.table               = ./BPCAL/calparameters_1934_bp_SB<SB1934STR>.tab.xy

EOFINNER

log=./script_io/POLCAL/logFiles/bpapply_sci_interA_${BEAM_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalapply -c $parset > $log
err=$?

"""

			if makeCopies==off:
				copyString = 'cp -Trv ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}.ms ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}_preBPapply.ms'
				a.replace(copyString,'')

			with open(baseDir+'slurmFiles/POLCAL/apply_bandpass_science_'+str(interleave)+'.sbatch','wb') as f:
				print '> Writing apply_bandpass_science_'+str(interleave)+'.sbatch...'
				f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<INTERSTR>',str(interleave)).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))



	a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=00:10:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_onAxFindepLeakCal
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/calibonaxis_findepleakages_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/calibonaxis_findepleakages_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

#^^The array should refer to the beam indexes

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

parset=./slurmFiles/POLCAL/slurmInput/calibonaxis_findepleakages.b${BEAM_ID}.in

CHAN=`expr ${CHANNEL_ID} \* ${NCHAN}`

cat > $parset << EOFINNER

Ccalibrator.dataset                               = ./BPCAL/1934_SB<SB1934STR>_beam${BEAM_ID}_postXYapply.ms
Ccalibrator.nAnt                                  = <NANTSTR>
Ccalibrator.nBeam                                 = 1
Ccalibrator.refantenna                            = <ROTANTSTR>
Ccalibrator.solve                                 = antennagains,leakages
Ccalibrator.MinUV                                 = 100
Ccalibrator.calibaccess                           = table
Ccalibrator.calibaccess.table                    = ./script_io/parset_findepleakages.b${BEAM_ID}.tab
Ccalibrator.sources.names                         = [field1]
Ccalibrator.sources.field1.direction              = [19h39m25.036, -63.42.45.63, J2000]
Ccalibrator.sources.field1.components             = src
Ccalibrator.sources.src.calibrator                = 1934-638
Ccalibrator.gridder                               = SphFunc
Ccalibrator.ncycles                               = 25


EOFINNER

log=./script_io/POLCAL/logFiles/calibonaxis_findepleakages.b${BEAM_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalibrator -c $parset > $log
"""

	with open(baseDir+'slurmFiles/POLCAL/calibonaxis_freqindep_leakages_allbeamschans.sbatch','wb') as f:
		print '> Writing calibonaxis_freqindep_leakages_allbeamschans.sbatch...'
		f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))


	for interleave in interleavesList:
		if interleave!='N': 

			a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=12:00:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_<INTERSTR>_applyLeakSci
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/applygaincalibonaxis_sci_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/applygaincalibonaxis_sci_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

#copy the 1934 tasks 
cp -Trv ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}.ms ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}_prefindepleak.ms #this is in case we need a redo

#Generate a parset for applying the calibration to 1934
parset=./slurmFiles/POLCAL/slurmInput/applyfreqindepgainsleaks_sci_inter<INTERSTR>_b${BEAM_ID}.in

cat > $parset << EOFINNER
Ccalapply.dataset                         = ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}.ms
#
# Allow flagging of vis if inversion of Mueller matrix fails
Ccalapply.calibrate.allowflag             = true
Ccalapply.calibrate.scalenoise            = false
Ccalapply.calibaccess                     = table
Ccalapply.calibaccess.table              =./script_io/parset_findepleakages.b${BEAM_ID}.tab
Ccalapply.calibrate.ignorebeam            = true

EOFINNER

log=./script_io/POLCAL/logFiles/applyfreqindepgainsleaks_sci_inter<INTERSTR>_b${BEAM_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalapply -c $parset > $log
err=$?

""" 

			if makeCopies==off:
				copyString = 'cp -Trv ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}.ms ./<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>_T<RIDICULOUSSTR><INTERSTR>.beam${BEAM_ID}_prefindepleak.ms #this is in case we need a redo'
				a.replace(copyString,'')

			with open(baseDir+'slurmFiles/POLCAL/applyonaxis_freqindepgainleakagecal_allbeams_science_'+str(interleave)+'.sbatch','wb') as f:
				print '> Writing applyonaxis_freqindepgainleakagecal_allbeams_science_'+str(interleave)+'.sbatch...'
				f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<INTERSTR>',str(interleave)).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))

		elif interleave=='N': 

			a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=12:00:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_<INTERSTR>_applyLeakSci
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/applygaincalibonaxis_sci_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/applygaincalibonaxis_sci_%A_%a.err
#SBATCH --array=0-"""+str(nBeam)+"""

# Using user-defined askapsoft module
module use /group/askap/modulefiles
module load askapdata

BASEDIR=<BASESTR>
cd $BASEDIR


#Get the beam identifier string
BEAM_ID=`printf %02d ${SLURM_ARRAY_TASK_ID}` #Pad with leading zeros to a total of two integers

#copy the 1934 tasks 
cp -Trv ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}.ms ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}_prefindepleak.ms #this is in case we need a redo

#Generate a parset for applying the calibration to 1934
parset=./slurmFiles/POLCAL/slurmInput/applyfreqindepgainsleaks_sci_inter<INTERSTR>_b${BEAM_ID}.in

cat > $parset << EOFINNER
Ccalapply.dataset                         = ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}.ms
#
# Allow flagging of vis if inversion of Mueller matrix fails
Ccalapply.calibrate.allowflag             = true
Ccalapply.calibrate.scalenoise            = false
Ccalapply.calibaccess                     = table
Ccalapply.calibaccess.table              =./script_io/parset_findepleakages.b${BEAM_ID}.tab
Ccalapply.calibrate.ignorebeam            = true

EOFINNER

log=./script_io/POLCAL/logFiles/applyfreqindepgainsleaks_sci_inter<INTERSTR>_b${BEAM_ID}.log

NCORES=1
NPPN=1
srun --export=ALL --ntasks=${NCORES} --ntasks-per-node=${NPPN} ccalapply -c $parset > $log
err=$?

""" 

			if makeCopies==off:
				copyString = 'cp -Trv ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}.ms ./<FIELDSTR>/scienceData_SB<SBSCIENCESTR>_<FIELDSTR>.beam${BEAM_ID}_prefindepleak.ms #this is in case we need a redo'
				a.replace(copyString,'')

			with open(baseDir+'slurmFiles/POLCAL/applyonaxis_freqindepgainleakagecal_allbeams_science_'+str(interleave)+'.sbatch','wb') as f:
				print '> Writing applyonaxis_freqindepgainleakagecal_allbeams_science_'+str(interleave)+'.sbatch...'
				f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<INTERSTR>',str(interleave)).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))


	a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=00:30:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_calcXYphase
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/calcXY_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/calcXY_%A_%a.err

apply_XY_phase_to_bandpass.py <BASESTR> ./BPCAL/calparameters_1934_bp_SB<SB1934STR>.tab -a <ROTANTSTR> -n <NBEAMSTR> -b <NCHANSTR> -s <ROTSENSSTR> 
"""

	with open(baseDir+'slurmFiles/POLCAL/apply_XY_phase_to_bandpass.sbatch','wb') as f:
		print '> Writing apply_XY_phase_to_bandpass.sbatch...'
		f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NBEAMSTR>',str(nBeam+1)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))


	if doLeakPlots==1:

		a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=00:30:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_plotLeaksPre
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/plotLeaksPre_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/plotLeaksPre_%A_%a.err

plotLeakageParsets.py <BASESTR> -n <NANTSTR> -c <NCHANSTR> -b <NBEAMSTR> -p 0
"""

		with open(baseDir+'slurmFiles/POLCAL/plotFDepLeaksBeforeXY.sbatch','wb') as f:
			print '> Writing plotFDepLeaksBeforeXY.sbatch...'
			f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NBEAMSTR>',str(nBeam)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))


		a = """#!/bin/bash -l
#SBATCH --partition=workq
#SBATCH --clusters=galaxy
#SBATCH --account=askap
#SBATCH --time=00:30:00
#SBATCH --ntasks=1
#SBATCH --ntasks-per-node=1
#SBATCH --job-name=<FIELDSTRSHORT>_plotLeaksPost
#SBATCH --mail-user=<MAILSTR>
#SBATCH --mail-type=ALL
#SBATCH --export=NONE
#SBATCH --output=<BASESTR>slurmFiles/POLCAL/slurmOutput/plotLeaksPost_%A_%a.out
#SBATCH --error=<BASESTR>slurmFiles/POLCAL/slurmError/plotLeaksPost_%A_%a.err

plotLeakageParsets.py <BASESTR> -n <NANTSTR> -c <NCHANSTR> -b <NBEAMSTR> -p 1
"""

		with open(baseDir+'slurmFiles/POLCAL/plotFDepLeaksAfterXY.sbatch','wb') as f:
			print '> Writing plotFDepLeaksAfterXY.sbatch...'
			f.write(a.replace('<BASESTR>',str(baseDir)).replace('<SB1934STR>',str(sb1934)).replace('<SBSCIENCESTR>',str(sbScience)).replace('<RIDICULOUSSTR>',str(ridiculousStr)).replace('<FIELDSTR>',str(fieldName)).replace('<FIELDSTRSHORT>',str(fieldName)[0:3]).replace('<ROTANTSTR>',str(rotAnt)).replace('<ROTSENSSTR>',str(rotSens)).replace('<NANTSTR>',str(nAnt)).replace('<NBEAMSTR>',str(nBeam)).replace('<NCHANSTR>',str(nChan)).replace('<MAILSTR>',str(mailTo)))

	else:
		pass


	##Submit jobs to slurm queue with appropriate dependencies

	if submit_jobs==on:

		accumulatedStatus=[]
		accumulatedJobs=[]

		print ''
		print ''
		print 'Submitting jobs...'
		print ''

		# submit the apply_bandpass_1934 job
		cmd = 'sbatch '+baseDir+'slurmFiles/POLCAL/apply_bandpass_1934.sbatch'
		status, infoStr = commands.getstatusoutput(cmd)
		jobnum_apply_bandpass_1934 = int(re.search(r'\d+', infoStr).group())
		if (status == 0):
			print '> apply_bandpass_1934 submitted successfully with job ID %s' %jobnum_apply_bandpass_1934
		else:
			print '> Error submitting apply_bandpass_1934 job!'
		accumulatedStatus.append(status)
		accumulatedJobs.append(jobnum_apply_bandpass_1934)

		# submit the 'calculate leakages' job, dependent on successful execution of the apply_bandpass_1934 job
		cmd = 'sbatch --dependency=afterok:%s '%jobnum_apply_bandpass_1934+baseDir+'slurmFiles/POLCAL/calibonaxis_freqdep_leakages_allbeamschans.sbatch' 
		status, infoStr = commands.getstatusoutput(cmd)
		jobnum_calibonaxis_freqdep_leakages = int(re.search(r'\d+', infoStr).group())
		if (status == 0):
			print '> calibonaxis_freqdep_leakages_allbeamschans submitted successfully with job ID %s with afterok dependency on %s' %(jobnum_calibonaxis_freqdep_leakages,jobnum_apply_bandpass_1934)
		else:
			print '> Error submitting calibonaxis_freqdep_leakages_allbeamschans job!'
		accumulatedStatus.append(status)
		accumulatedJobs.append(jobnum_calibonaxis_freqdep_leakages)

		#submit the flag_bad_polcal_channels job, dependent on successful execution of the 'calculate leakages' job
		cmd = 'sbatch --dependency=afterok:%s '%jobnum_calibonaxis_freqdep_leakages+baseDir+'slurmFiles/POLCAL/flag_bad_polcal_channels.sbatch' 
		status, infoStr = commands.getstatusoutput(cmd)
		jobnum_flag_bad_polcal_channels = int(re.search(r'\d+', infoStr).group())
		if (status == 0):
			print '> flag_bad_polcal_channels submitted successfully with job ID %s with afterok dependency on %s' %(jobnum_flag_bad_polcal_channels,jobnum_calibonaxis_freqdep_leakages)
		else:
			print '> Error submitting flag_bad_polcal_channels job!'
		accumulatedStatus.append(status)
		accumulatedJobs.append(jobnum_flag_bad_polcal_channels)

		#once the bad channels have been flagged, re-calculate the leakages in each 1 MHz channel so that the bad channels will be flagged out. Note that the jobs will move the old leakage parsets to an awdleakparsets dir
		cmd = 'sbatch --dependency=afterok:%s '%jobnum_flag_bad_polcal_channels+baseDir+'slurmFiles/POLCAL/calibonaxis_freqdep_leakages_allbeamschans.sbatch' 
		status, infoStr = commands.getstatusoutput(cmd)
		jobnum_calibonaxis_freqdep_leakages_2 = int(re.search(r'\d+', infoStr).group())
		if (status == 0):
			print '> calibonaxis_freqdep_leakages_allbeamschans (after flagging) submitted successfully with job ID %s with afterok dependency on %s' %(jobnum_calibonaxis_freqdep_leakages_2,jobnum_flag_bad_polcal_channels)
		else:
			print '> Error submitting calibonaxis_freqdep_leakages_allbeamschans job!'
		accumulatedStatus.append(status)
		accumulatedJobs.append(jobnum_calibonaxis_freqdep_leakages_2)

		#submit the pre-XY-phase-correction leakage plotter job, with afterok dep on the calibonaxis_freqdep_leakages_allbeamschans job
		if doLeakPlots==1:
			cmd = 'sbatch --dependency=afterany:%s '%jobnum_calibonaxis_freqdep_leakages_2+baseDir+'slurmFiles/POLCAL/plotFDepLeaksBeforeXY.sbatch'
			status, infoStr = commands.getstatusoutput(cmd)
			jobnum_plotFDepLeaksBeforeXY = int(re.search(r'\d+', infoStr).group())
			if (status == 0):
				print '> plotFDepLeaksBeforeXY submitted successfully with job ID %s with afterok dependency on %s' %(jobnum_plotFDepLeaksBeforeXY,jobnum_calibonaxis_freqdep_leakages_2)
			else:
				print '> Error submitting plotFDepLeaksBeforeXY job!'
			accumulatedStatus.append(status)
			accumulatedJobs.append(jobnum_plotFDepLeaksBeforeXY)

		# submit the apply_XY_phase_to_bandpass job, dependent on successful execution of the 'calculate leakages' job
		cmd = 'sbatch --dependency=afterany:%s '%jobnum_calibonaxis_freqdep_leakages_2+baseDir+'slurmFiles/POLCAL/apply_XY_phase_to_bandpass.sbatch' 
		status, infoStr = commands.getstatusoutput(cmd)
		jobnum_apply_XY_phase_to_bandpass = int(re.search(r'\d+', infoStr).group())
		if (status == 0):
			print '> apply_XY_phase_to_bandpass submitted successfully with job ID %s with afterany dependency on %s' %(jobnum_apply_XY_phase_to_bandpass,jobnum_calibonaxis_freqdep_leakages_2)
		else:
			print '> Error submitting apply_XY_phase_to_bandpass job!'
		accumulatedStatus.append(status)
		accumulatedJobs.append(jobnum_apply_XY_phase_to_bandpass)

		# submit the apply_bandpass_1934_postXY job, dependent on successful exec of apply_XY_phase_to_bandpass
		cmd = 'sbatch --dependency=afterok:%s '%jobnum_apply_XY_phase_to_bandpass+baseDir+'slurmFiles/POLCAL/apply_bandpass_1934_postxy.sbatch' 
		status, infoStr = commands.getstatusoutput(cmd)
		jobnum_apply_bandpass_1934_postxy = int(re.search(r'\d+', infoStr).group())
		if (status == 0):
			print '> apply_bandpass_1934_postxy submitted successfully with job ID %s with afterok dependency on %s' %(jobnum_apply_bandpass_1934_postxy,jobnum_apply_XY_phase_to_bandpass)
		else:
			print '> Error submitting apply_bandpass_1934_postxy job!'
		accumulatedStatus.append(status)
		accumulatedJobs.append(jobnum_apply_bandpass_1934_postxy)

		# submit the 're-calculate leakages' job (as a check for successful elimination of the XY phase), dependent on successful execution of the apply_bandpass_1934_postXY job
		cmd = 'sbatch --dependency=afterok:%s '%jobnum_apply_bandpass_1934_postxy+baseDir+'slurmFiles/POLCAL/calibonaxis_freqdep_leakages_allbeamschans_doover.sbatch' 
		status, infoStr = commands.getstatusoutput(cmd)
		jobnum_calibonaxis_freqdep_leakages_doover = int(re.search(r'\d+', infoStr).group())
		if (status == 0):
			print '> Re-calculate leakages post-XY job submitted successfully with job ID %s with afterok dependency on %s' %(jobnum_calibonaxis_freqdep_leakages_doover,jobnum_apply_bandpass_1934_postxy)
		else:
			print '> Error submitting round 2 of the calibonaxis_freqdep_leakages_allbeamschans job!'
		accumulatedStatus.append(status)
		accumulatedJobs.append(jobnum_calibonaxis_freqdep_leakages_doover)

		# submit the apply_bandpass_science job, dependent on successful exec of apply_XY_phase_to_bandpass
		for interleave in interleavesList:

			cmd = 'sbatch --dependency=afterok:%s '%jobnum_apply_XY_phase_to_bandpass+baseDir+'slurmFiles/POLCAL/apply_bandpass_science_'+str(interleave)+'.sbatch' 
			status, infoStr = commands.getstatusoutput(cmd)
			jobnum_apply_bandpass_science = int(re.search(r'\d+', infoStr).group())
			if (status == 0):
				print '> apply_bandpass_science (interleave '+str(interleave)+') submitted successfully with job ID %s with afterany dependency on %s' %(jobnum_apply_bandpass_science,jobnum_apply_XY_phase_to_bandpass)
			else:
				print '> Error submitting apply_bandpass_science (interleave '+str(interleave)+') job!'
			accumulatedStatus.append(status)
			accumulatedJobs.append(jobnum_apply_bandpass_science)	

		# submit the calibonaxis_freqindep_leakages_allbeamschans job, dependent on successful exec of apply_bandpass_1934_postxy
		cmd = 'sbatch --dependency=afterok:%s ' %jobnum_apply_bandpass_1934_postxy+baseDir+'slurmFiles/POLCAL/calibonaxis_freqindep_leakages_allbeamschans.sbatch'
		status,infoStr = commands.getstatusoutput(cmd)
		jobnum_calibonaxis_freqindep_leakages = int(re.search(r'\d+', infoStr).group())
		if (status == 0):
			print '> calibonaxis_freqindep_leakages_allbeamschans submitted successfully with job ID %s with afterok dependency on %s' %(jobnum_calibonaxis_freqindep_leakages,jobnum_apply_bandpass_1934_postxy)
		else:
			print '> Error submitting calibonaxis_freqindep_leakages_allbeamschans job!'
		accumulatedStatus.append(status)
		accumulatedJobs.append(jobnum_calibonaxis_freqindep_leakages)		

		# submit the applyonaxis_freqindepgainleakagecal_allbeams_science job, dependent on successful exec of calibonaxis_freqindep_leakages_allbeamschans and apply_bandpass_science jobs
		for interleave in interleavesList:

			cmd = 'sbatch --dependency=afterok:%s,%s '%(jobnum_calibonaxis_freqindep_leakages,jobnum_apply_bandpass_science)+baseDir+'slurmFiles/POLCAL/applyonaxis_freqindepgainleakagecal_allbeams_science_'+str(interleave)+'.sbatch' 
			status,infoStr = commands.getstatusoutput(cmd)
			jobnum_applyonaxis_freqindepgainleakagecal = int(re.search(r'\d+', infoStr).group())
			if (status == 0):
				print '> applyonaxis_freqindepgainleakagecal_allbeams_science (interleave '+str(interleave)+') submitted successfully with job ID %s with afterok dependencies on %s, %s' %(jobnum_applyonaxis_freqindepgainleakagecal,jobnum_calibonaxis_freqindep_leakages,jobnum_apply_bandpass_science)
			else:
				print '> Error submitting applyonaxis_freqindepgainleakagecal_allbeams_science (interleave '+str(interleave)+') job!'
			accumulatedStatus.append(status)
			accumulatedJobs.append(jobnum_applyonaxis_freqindepgainleakagecal)	

		# finish up
		if not np.any(accumulatedStatus.append(status)):
			print ''
			print 'All jobs submitted successfully. If all jobs complete, you may be able to proceed with science target imaging and selfcal. Good luck!'
			print ''
			print 'Full list of job IDs:'
			print accumulatedJobs
			print ''
		else:
			print 'There were job submission failures! Check screen output for any error messages. You may want to scancel the job numbers printed below...'
			print ''
			print 'Full list of job IDs:'
			print accumulatedJobs
			print '' 
	else:
		print ''
		print 'The .sbatch files were generated, but will NOT be submitted for processing. Your cautiousness is mildly irritating.' 
		print ''

#Arg parsing
ap = argparse.ArgumentParser(description=genInfo)
ap.add_argument('baseDir',help='Directory within which the script_io subdirectory is found')
ap.add_argument('sb1934',help='The scheduling block number of the 1934 calibrator observations')
ap.add_argument('sbScience',help='The scheduling block number of the target (science) observations')
ap.add_argument('ridiculousStr',help='The ridiculous string that is included in some esoteric field names --- e.g. the \'7-0\' part of COSMOLOGY_T7-0A')
ap.add_argument('fieldName',help='The name of the field, as recorded in the OMP and metadata (e.g. <FIELDSTR>)')
ap.add_argument('interleavesList',help='A comma-separated list of interleaves to apply the polarisation calibration to (e.g. A,B). If interleaving was not used, use N.')
ap.add_argument('--rotAnt','-r',help='Antenna index corresponding to rotated PAF [default 0]',default=0,type=int)
ap.add_argument('--rotSens','-s',help='The sense of the rotation of the rotated PAF [counterclockwise=-1, clockwise=1; default -1]',default=-1,type=int)
ap.add_argument('--nAnt','-n',help='Number of antennas in the array for the observations [default 12]',default=12,type=int)
ap.add_argument('--nChan','-c',help='Number of 1 MHz channels across the full bandwidth for the observations [default 240]',default=240,type=int)
ap.add_argument('--nBeams','-b',help='Number of formed beams in the observations [default 36]',default=36,type=int)
ap.add_argument('--mailTo','-m',help='Send notifications from Galaxy to this email account',default='craig.anderson@csiro.au',type=str)
ap.add_argument('--submit_jobs','-j',help='Submit sbatch jobs to galaxy? [1==submit, 0==generate sbatch files only; default=0] ',default=0,type=int)
ap.add_argument('--clean_up','-k',help='If you\'ve run the pipeline before on a given data set, use this option to clobber old data products before re-running.  [1==clean up, 0==leave things alone (may fail with errors); default=0] ',default=0,type=int)
ap.add_argument('--doLeakPlots','-p',help='Do plots of the frequency-dependent leakages before and after XY-phase correction.  [1==plot, 0==do not plot); default=0] ',default=0,type=int)
ap.add_argument('--makeCopies','-w',help='Save backup copies of the science measurement sets before applying calibrations? Note that this can dramatically increase disk usage.  [1==Make backups, 0==Do not make backups); default=0] ',default=0,type=int)

args = ap.parse_args()
main(args)

